<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="Watershed" Id="{68aab67d-8dd2-4dbe-9739-4720453e68ea}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK Watershed 
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	//Camera or file source
	hr: HRESULT;
	fbCamera: FB_VN_SimpleCameraControl;
	eState: ETcVnCameraState;

//Images for realtime work
	ipImageIn: ITcVnImage;
	ipImageGrey: ITcVnImage;
	ipImageBinary: ITcVnImage;
	ipMarkersImage: ITcVnImage;
	ipSingleMarkerBinaryImage: ITcVnImage;
	ipSureBackground: ITcVnImage;
	ipSureForeground: ITcVnImage;
	ipUnknown: ITcVnImage;
	ipValue_1_Image	: ITcVnImage;
	ipWatershed: ITcVnImage;
	
	//Structure element
		ipElement: ITcVnImage;
		nWidthHeight: UDINT:= 9; //Same variable used for both Width and height

//Otsu binary
	ETcVnThresholdType: ETcVnThresholdType :=TCVN_TT_OTSU_BINARY;

//Displayable images (for ADS Image watch and TwinCAT HMI
	ipImageInDisp: ITcVnDisplayableImage;
	ipImageGreyDisp:	ITcVnDisplayableImage;	
	ipImageBinaryDisp: ITcVnDisplayableImage;
	ipMarkersImageDisp:		ITcVnDisplayableImage;
	ipSureBackgroundDisp:		ITcVnDisplayableImage;
	ipSureforegroundDisp:		ITcVnDisplayableImage;
	ipDistanceTransformDisp:		ITcVnDisplayableImage;
	ipUnknownDisp:		ITcVnDisplayableImage;
	ipWatershedDisp:		ITcVnDisplayableImage;
	
//Step 3	
	fThreshold: LREAL:=59;
	
	//Containers, used to hold individual contours or  lists of contours	
	ipContour:		ITcVnContainer;
	ipContours: 	ITCVnContainer;
	ipSingleContour:		ITcVnContainer; 	

//Iterators
	ipIteratorContours: 	ITcVnForwardIterator;

	

	//Draw
	sText: STRING;
	aColorRed	: TcVnVector4_LREAL:= [255,0,0,0];
	aColorBlue	: TcVnVector4_LREAL:= [0,0,255,0];

	//Markers from F_VN_ConnectedComponents
	nLabels: DINT;
	
	aMaxValue: TcVnVector4_LREAL;
	
	aPosition: TcVnPoint2_DINT;
	ipDistanceTransform: ITcVnImage;

	
	//STEP 6.2 
	aValue: TcVnVector4_LREAL:=[1.0,0.0,0.0,0.0]; //Add 1 to the single channel image.	
	nWidth: UDINT;
	nHeight: UDINT;
	
	stImageInfoGrey: TcVnImageInfo;
	stImageInfoWatershed: TcVnImageInfo;
	stMarkersLabel: TcVnImageInfo;

	
aMaxValueMarker: TcVnVector4_LREAL;	
	Currentmarker: ULINT;
	markerColor:		TcVnVector4_LREAL;

	              nContours                           : ULINT;
				  
	rotatedRectangle: TcVnRotatedRectangle;			  
	stEllipse: TcVnRotatedRectangle;	

fbWithoutWaterShed:WithoutWaterShed();
stImageInfo: TcVnImageInfo;
		  
END_VAR






]]></Declaration>
    <Implementation>
      <ST><![CDATA[
//I have used an article about watershedding that is based on python. See it here for explanations. The chapter numbers in the comments come from the article as well.
//https://www.geeksforgeeks.org/image-segmentation-with-watershed-algorithm-opencv-python/


//To do
// 1. Under the FileSource1-folder. Press button "read from target" and then press "add images" 
//and add the image mynt.bmp in the TwinCAT project tree under the folder ImageForExample
//2. Watch the different images under the "ADS Image Watch"-window. 



eState:= fbCamera.GetState();

IF eState = TCVN_CS_ERROR THEN
	hr:= fbCamera.Reset();
	
ELSIF eState<TCVN_CS_ACQUIRING THEN
	hr:= fbCamera.StartAcquisition();
	
ELSIF eState= TCVN_CS_ACQUIRING THEN
	
	//Get the image from camera. Or in this case a file source
	// Step 1 - Import image
	hr:= fbCamera.GetCurrentImage(ipImageIn);
	
	IF SUCCEEDED(hr) AND ipImageIn <> 0 THEN
//Step 2 - Preprocessing - Greyscale the image and possible filtering		
hr:= F_VN_ConvertColorSpace(ipImageIn, ipImageGrey, TCVN_CST_RGB_TO_GRAY, hr);

//Step 3- Threshold image to get a binary image
 hr := F_VN_Threshold(
    ipSrcImage      :=  ipImageGrey,
    ipDestImage     :=  ipImageBinary,
    fThreshold      :=  fThreshold, // If otsu is used as in this case. The value here is automatically set.
    fMaxValue       :=  255, // max value of 8-bit image: (2^8)-1=255
    eThresholdType  :=  ETcVnThresholdType,
    hrPrev          :=  hr
);

// STEP 4 - Noise removal by Morphological operators. More here --- https://pyimagesearch.com/2021/04/28/opencv-morphological-operations/
hr := F_VN_FillHoles(
    ipSrcImage      :=  ipImageBinary,
    ipDestImage     :=  ipImageBinary,
    hrPrev          :=  hr
);

		hr := F_VN_CreateStructuringElement(
			ipStructuringElement    :=  ipElement,
			eShape                  :=  TCVN_SES_RECTANGLE,
			nWidth                  :=  nWidthHeight,
			nHeight                 :=  nWidthHeight,
			hrPrev                  :=  hr );

		hr := F_VN_MorphologicalOperator(
			ipSrcImage  :=  ipImageBinary,
			ipDestImage :=  ipImageBinary,
			eOperator   :=  TCVN_MO_OPENING,
			ipStructuringElement  :=  ipElement,
			hrPrev      :=  hr
		);

		
				// CAll WithoutWaterShed to show what happens without the watershed-function
					fbWithoutWaterShed(ipImageBinary:=ipImageBinary, ipImageIn:=ipImageIn, hr:=hr);
		
		
//Step 5: Grasping the black background AND foreground OF the image

//STEP 5.1 sure background with "dilation" (morphological operator)
			hr := F_VN_MorphologicalOperator(
			ipSrcImage  :=  ipImageBinary,
			ipDestImage :=  ipSureBackground,
			eOperator   :=  TCVN_MO_DILATION,
			ipStructuringElement  :=  ipElement,
			hrPrev      :=  hr
		);

//STEP 5.2 distance Transform. To find the longest distance to the background (black pixel) for every pixel.
hr := F_VN_DistanceTransformation(
    ipSrcImage      :=  ipImageBinary,
    ipDestImage     :=  ipDistanceTransform,
    eDistanceType   :=  TCVN_DT_C, 
    eMaskSize       :=  TCVN_DTM_3,
    hr);	

// STEP 5.3 - Find out what is sure to be foreground
hr:=F_VN_MaxPixelValue(ipDistanceTransform, aMaxValue, aPosition, hr);


hr := F_VN_Threshold(
    ipSrcImage      :=  ipDistanceTransform,
    ipDestImage     :=  ipSureForeground,
    fThreshold      :=  aMaxValue[0]*0.5, // half value range: (2^8)/2=128
    fMaxValue       :=  255, // max value of 8-bit image: (2^8)-1=255
    eThresholdType  :=  TCVN_TT_BINARY,
    hrPrev          :=  hr
);

//Convert to USINT since the multiplication above creates a REAL-pixel image. TwinCAT Image view requires USINT
hr := F_VN_ConvertElementType(ipSureForeground, ipSureForeground, TCVN_ET_USINT, hr); 

// STEP 5.4 - Subtract sure background from foregrund to get the unknown region that could be either one or the other.
hr:=F_VN_SubtractImages(ipSureBackground,ipSureForeground, ipUnknown, hr);

//STEP 6.1 Create the labels on the sure foreground fields. 1, 2, 3, ....n. 
hr:=F_VN_ConnectedComponents(ipSureForeground, ipMarkersImage, nLabels, hr);

//STEP 6.2 - To distinguish the background and foreground, the values in “markers” are incremented by 1.
hr:=F_VN_GetImageWidth(ipImageIn,nWidth,hr);
hr:=F_VN_GetImageHeight(ipImageIn,nHeight,hr);
hr:= F_VN_CreateImageAndSetPixels(ipValue_1_Image,nWidth, nHeight,TCVN_ET_DINT, 1, aValue, hr);
hr:=F_VN_AddImages(ipMarkersImage, ipValue_1_Image, ipMarkersImage, hr);

//STEP 6.3- Label unknown region with 0 in ipMarkersImage
hr:= F_VN_BitwiseNotImage(ipUnknown,ipUnknown, hr);
hr := F_VN_ConvertElementType(ipUnknown, ipUnknown, TCVN_ET_DINT, hr); 
hr:= F_VN_BitwiseAndImages(ipMarkersImage,ipUnknown,ipMarkersImage, hr);

//Get image data have a look if it is DINT or USINT
F_VN_GetImageInfo(ipImageGrey, stImageInfoGrey,hr);
F_VN_GetImageInfo(ipWatershed, stImageInfoWatershed,hr);
F_VN_GetImageInfo(ipMarkersImage, stMarkersLabel,hr);

//	7.1 Apply watershed Algorithm to markers	
hr:= F_VN_WatershedSegmentationExp(ipImageIn,ipWatershed, ipMarkersImage,hr);

//7.3 Loop and iterate over the markers. First found contour for the specific marker area is appended to a list of contours. 
hr:=F_VN_MaxPixelValue(ipWatershed, aMaxValueMarker, aPosition, hr);

hr:= F_VN_CreateContainer(ipContours, ContainerType_Vector_Vector_TcVnPoint2_DINT,0, hr);  
		hr:= F_VN_ReserveContainerMemory(ipContours, 100, hr);  //Only for performance reasons

	hr := F_VN_GetForwardIterator(ipContours, ipIteratorContours, hr);

		FOR Currentmarker:=2 TO  LREAL_TO_ULINT(aMaxValueMarker[0]) DO //
			
			markerColor[0]:= ULINT_TO_LREAL(Currentmarker);

			hr:= F_VN_CheckColorRange(ipWatershed, ipSingleMarkerBinaryImage,markerColor,markerColor,hr); //make binary with only one marker area
			hr := F_VN_FindContours(ipSrcImage  :=  ipSingleMarkerBinaryImage,ipContours := ipContour,hrPrev:= hr);
	                            
			
			// Get one contour for the specific marker
			hr:=F_VN_GetAt_ITcVnContainer(ipContour,ipSingleContour, 0, hr);
			
			// Populate ipContours with the corrently retrieved contour from the specific marker
			hr:=F_VN_InsertIntoContainer_ITcVnContainer(ipSingleContour,ipContours,Currentmarker-2, hr);
			
		END_FOR

			//Draw
				hr:= F_VN_DrawContours(ipContours, -1, ipImageIn, aColorRed, 1, hr);
                hr := F_VN_GetNumberOfElements(ipContours, nContours, hr);
                sText := CONCAT('Contours: ', TO_STRING(nContours));
                hr := F_VN_PutText(sText, ipImageIn, 5, 30, TCVN_FT_HERSHEY_SIMPLEX, 1, aColorRed, hr);

				//GeometricData(rotatedRectangle, ipSingleContour, stEllipse);   //Method call optional.
		
////Convert to USINT see image in Image Watch
hr := F_VN_ConvertElementType(ipWatershed, ipWatershed, TCVN_ET_USINT, hr); 
hr := F_VN_ConvertElementType(ipMarkersImage, ipMarkersImage, TCVN_ET_USINT, hr);
hr := F_VN_ConvertElementType(ipUnknown, ipUnknown, TCVN_ET_USINT, hr);
hr := F_VN_ConvertElementType(ipDistanceTransform, ipDistanceTransform, TCVN_ET_USINT, hr);
	
//		//Create images to display for the different processing steps
		hr:= F_VN_CopyIntoDisplayableImage(ipImageIn, ipImageInDisp, hr);
		hr:= F_VN_CopyIntoDisplayableImage(ipImageGrey, ipImageGreyDisp, hr); 
		hr:= F_VN_CopyIntoDisplayableImage(ipImageBinary, ipImageBinaryDisp, hr);  
		hr:= F_VN_CopyIntoDisplayableImage(ipSureBackground, ipSureBackgroundDisp, hr);  
		hr:= F_VN_CopyIntoDisplayableImage(ipSureForeground, ipSureForegroundDisp, hr);  
		hr:= F_VN_CopyIntoDisplayableImage(ipMarkersImage, ipMarkersImageDisp, hr);  
		hr:= F_VN_CopyIntoDisplayableImage(ipDistanceTransform, ipDistanceTransformDisp, hr);  
		hr:= F_VN_CopyIntoDisplayableImage(ipUnknown, ipUnknownDisp, hr);  
		hr:= F_VN_CopyIntoDisplayableImage(ipWatershed, ipWatershedDisp, hr);
	END_IF

END_IF
]]></ST>
    </Implementation>
    <Method Name="GeometricData" Id="{5f6856ea-2eb4-418c-9310-7081b8504a7c}">
      <Declaration><![CDATA[METHOD GeometricData : BOOL
VAR_INPUT
		stOrientation: REFERENCE TO TcVnRotatedRectangle;
		
		ipSingleContour:	REFERENCE TO 	ITcVnContainer;
		stEllipse: REFERENCE TO TcVnRotatedRectangle;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//hr:=F_VN_FillContours(ipContours, 2, ipImageIn, aColorRed, hr);

// Get one contour for the specific marker
			hr:=F_VN_GetAt_ITcVnContainer(ipContours,ipSingleContour, 3, hr);

			hr:= F_VN_ContourOrientation(ipSingleContour, stOrientation, hr);
//Fit an Ellipse inside one coin. Use the data in "stEllipse" to coordinate for example a gripping arm
			hr:=F_VN_FitEllipse(ipSingleContour, stEllipse, hr);
			
//Drawing	
			F_VN_DrawRotatedRectangle(stOrientation,ipImageIn, aColorRed, 1, hr);
			//F_VN_DrawRotatedRectangle(stEllipse,ipImageIn, aColorRed, 1, hr);
			F_VN_DrawEllipse(stEllipse,ipImageIn, aColorBlue, 1, hr);]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>